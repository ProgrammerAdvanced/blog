(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{268:function(t,s,e){t.exports=e.p+"assets/img/offset.1749d5d0.png"},278:function(t,s,e){"use strict";e.r(s);var o=e(10),r=Object(o.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("消费者不需要自行管理 offset（"),s("em",[t._v("分组+topic+分区")]),t._v("），系统通过 broker 将 offset 存放在本地。低版本通过 zk 自行管理。系统自行管理分区和副本情况。消费者断线后会自动根据上一次记录的 offset 去获取数据（默认一分钟更新一次 offset），同一个分组中的客户不能同时消费同一个分片。不同的 group 记录不同的 offset，这样不同程序读取同一个 topic 才不会因为 offset 互相影响。")]),t._v(" "),s("h2",{attrs:{id:"一、消费者组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、消费者组"}},[t._v("#")]),t._v(" 一、消费者组")]),t._v(" "),s("p",[s("img",{attrs:{src:e(268),alt:"offset"}}),t._v("\n分区的所有权从一个消费者转移到另一个消费者，这样的行为称为再均衡，再均衡非常重要，它为消费者群组带来了高可用性和伸缩性（可以放心的添加和删除消费者），再均衡期间消费者无法读取消息，造成整个群组一小段时间的不可用。另外，当分区被重新分配给另一个消费者时，消费者当前的读取状态会丢失，它有可能还需要去刷新缓存，在它重新恢复状态之前会拖慢应用程序。通过心跳机制检测消费者是否活跃。")]),t._v(" "),s("h2",{attrs:{id:"二、消费方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、消费方式"}},[t._v("#")]),t._v(" 二、消费方式")]),t._v(" "),s("p",[t._v(":::\n如果消费者提交了偏移量却未能处理完消息，那么就有可能造成消息丢失，这也是消费者丢失消息的主要原因。\n:::")])])}),[],!1,null,null,null);s.default=r.exports}}]);